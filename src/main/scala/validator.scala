import ast._
import waccErrors._

import java.io.File
import scala.collection.mutable
import scala.io.Source

object validator {

  private val nullPos: (Int, Int) = (-1, -1)
  val waccPrefix = "wacc_"

// Pair erasure, string weakening and other type flattening
  private def sameType(t1: Type, t2: Type): Boolean = {
    if (t1 == t2) {
      true
    } else (t1, t2) match {
      case (ArrayType(StringType()), ArrayType(ArrayType(CharType()))) => false
      case (ArrayType(arrType1), ArrayType(arrType2)) => sameType(arrType1, arrType2)

      case (PairType(StringType(), _), PairType(ArrayType(CharType()), _)) => false
      case (PairType(_, StringType()), PairType(_, ArrayType(CharType()))) => false
      case (PairType(t1l, t1r), PairType(t2l, t2r)) => sameType(t1l, t2l) && sameType(t1r, t2r)

      case (PairType(_, _), Pair()) => true
      case (Pair(), PairType(_, _)) => true
      case (StringType(), ArrayType(CharType())) => true
      case _ => if (t1 == AnyType || t2 == AnyType) true else false
    }
  }

  // Add to the errors generated by a WACC file after compilation to be returned to the user
  private def semanticErrorOccurred(reason: String, pos: (Int, Int))(implicit errors: mutable.ListBuffer[WaccError], source: String, waccLines: Array[String], scopePrefix: Option[String]): Unit = {
    errors += SemanticError.genError(reason, pos)
  }

  // Check that any Expression passed in as a LValue is of and/or contain the expected type(s)
  private def checkType(expr: LValue)(implicit symTable: mutable.Map[String, Type]): Type = {

    def pairOperation(value: LValue, isFirst: Boolean): Type = checkType(value) match {
      case Pair() => AnyType
      case PairType(fst, snd) => if (isFirst) fst else snd
      case _ => NoTypeExists
    }

    expr match {
      case Ident(name) => symTable.getOrElse(name, NoTypeExists)
      case ArrayElem(id, _) => checkType(id: Expr) match {
        case ArrayType(arrTyp) => arrTyp
        case _ => NoTypeExists
      }
      case PairFst(value) => pairOperation(value, isFirst = true)
      case PairSnd(value) => pairOperation(value, isFirst = false)
    }
  }

  private def checkNewPair(exp1: Expr, exp2: Expr)(implicit symTable: mutable.Map[String, Type]): PairType = {
    def resolvePairType(expr: Expr): PairElemType = checkType(expr) match {
      case PairType(_, _) => Pair()(nullPos)
      case pairType: PairElemType => pairType
      case _ => NoTypeExists
    }

    val exp1Type: PairElemType = resolvePairType(exp1)
    val exp2Type: PairElemType = resolvePairType(exp2)
    PairType(exp1Type, exp2Type)(null)
  }

  // Check that any Expression passed in as a RValue is of and/or contain the expected type(s)
  private def checkType(expr: RValue)(implicit symTable: mutable.Map[String, Type], funcTable: List[Func]): Type = expr match {
    case exp: Expr => checkType(exp)
    case NewPair(exp1, exp2) =>
      checkNewPair(exp1, exp2)
    case Call(ident, _) => funcTable.find(x => x.ident.name == ident.name) match {
      case Some(value) => value.typ
      case None => NoTypeExists
    }
    case PairFst(value) => checkType(value) match {
      case Pair() => AnyType
      case PairType(pairTyp, _) => pairTyp
      case _ => NoTypeExists
    }
    case PairSnd(value) => checkType(value) match {
      case Pair() => AnyType
      case PairType(_, pairTyp) => pairTyp
      case _ => NoTypeExists
    }
    case ArrayLit(elems) => if (elems.isEmpty) ArrayType(AnyType)(nullPos) else {
      ArrayType(getArrayLitType(elems))(nullPos)
    }
  }

  private def getArrayLitType(elems: List[Expr])(implicit symTable: mutable.Map[String, Type]): Type = {
    if (elems.isEmpty) {
      NoTypeExists
    } else {
      val arrayElementTypes: List[Type] = elems.map(checkType)
      if (arrayElementTypes.contains(StringType()(nullPos))) {
        StringType()(nullPos)
      } else {
        arrayElementTypes.head
      }
    }
  }

  // Check that any Expression passed in as a BinOp or UnOp is of and/or contain the expected type(s)
  private def checkType(expr: Expr)(implicit symTable: mutable.Map[String, Type]): Type = {
    expr match {
      case Sub(_, _) => IntType()(nullPos)
      case Add(_, _) => IntType()(nullPos)
      case Mul(_, _) => IntType()(nullPos)
      case Div(_, _) => IntType()(nullPos)
      case Mod(_, _) => IntType()(nullPos)
      case GT(_, _) => BoolType()(nullPos)
      case GTE(_, _) => BoolType()(nullPos)
      case LT(_, _) => BoolType()(nullPos)
      case LTE(_, _) => BoolType()(nullPos)
      case Eq(_, _) => BoolType()(nullPos)
      case NEq(_, _) => BoolType()(nullPos)
      case And(_, _) => BoolType()(nullPos)
      case Or(_, _) => BoolType()(nullPos)
      case Not(_) => BoolType()(nullPos)
      case Len(_) => IntType()(nullPos)
      case Neg(_) => IntType()(nullPos)
      case Ord(_) => IntType()(nullPos)
      case Chr(_) => CharType()(nullPos)
      case Plus(_) => IntType()(nullPos)
      case ArrayElem(id, _) => checkType(id:Expr) match {
        case ArrayType(insideType) => insideType
        case _ => NoTypeExists
      }
      case BoolLit(_) => BoolType()(nullPos)
      case IntLit(_) => IntType()(nullPos)
      case CharLit(_) => CharType()(nullPos)
      case Ident(name) => symTable.getOrElse(name, NoTypeExists)
      case StrLit(_) => StringType()(nullPos)
      case PairLiter() => PairType(AnyType, AnyType)(nullPos)

      case _: Atom => NoTypeExists
      case _: UnOpp => NoTypeExists
      case _: BinOpp => NoTypeExists
    }
  }

  private def createArrayElem(name: String, idPos: (Int, Int), indexes: List[Expr], exprPos: (Int, Int)): ArrayElem = {
    new ArrayElem(new Ident(name)(idPos), indexes)(exprPos)
  }


  // Check that any Expression passed in as a LValue is syntactically sound according to the WACC specification
  private def checkExpr(expr: LValue, varsInScope: mutable.Map[String, String])(implicit errors: mutable.ListBuffer[WaccError],
                                                                        symTable: mutable.Map[String, Type],
                                                                        funcTable: List[Func], source: String,
                                                                        waccLines: Array[String], funcName: Option[String]): LValue = {
    expr match {
      case id@Ident(name) =>
        resolveIdentifier(name, varsInScope, id)
      case ArrayElem(id, indexes) =>
        checkArrayIndex(indexes, varsInScope) match {
          case Some((err, pos)) => semanticErrorOccurred(err, pos)
          case _ =>
        }

        id match {
          case ArrayElem(_, _) =>
            checkExpr(id: Expr, varsInScope) match {
              case newId: Ident => new ArrayElem(newId, indexes)(expr.pos)
              case _ =>
                semanticErrorOccurred(s"Array identifier evaluates to incorrect type: $id", id.pos)
                expr
            }
          case Ident(name) =>
            symTable.get(varsInScope.getOrElse(name, "")) match {
              case Some(value) => value match {
                case ArrayType(_) => createArrayElem(varsInScope(name), id.pos, indexes, expr.pos)
                case _ =>
                  semanticErrorOccurred(s"Attempting to access array element from non-array identifier: $name", id.pos)
                  expr
              }
              case None =>
                semanticErrorOccurred(s"Identifier not in scope: $name", id.pos)
                expr
            }
        }
      case PairFst(value) => new PairFst(checkExpr(value, varsInScope))(expr.pos)
      case PairSnd(value) => new PairSnd(checkExpr(value, varsInScope))(expr.pos)
    }
  }

  private def checkArrayIndex(exprs: List[Expr], varsInScope: mutable.Map[String, String])(implicit errors: mutable.ListBuffer[WaccError],
                                                                                   symTable: mutable.Map[String, Type],
                                                                                   funcTable: List[Func], source: String,
                                                                                   waccLines: Array[String], funcName: Option[String]): Option[(String, (Int, Int))] = {
    for (expr <- exprs) {
      val newExpr = checkExpr(expr, varsInScope)
      checkType(newExpr)(symTable) match {
        case IntType() =>
        case _ => return Option("Array Indexes must be of type ⟨int⟩", expr.pos)
      }
    }
    None
  }

  private def getDimension(array:Type): Int = {
    array match {
      case ArrayType(x) => 1 + getDimension(x)
      case _ => 0
    }
  }



  // Check that any Expression passed in as a RValue is syntactically sound according to the WACC specification
  private def checkExpr(expr: RValue, varsInScope: mutable.Map[String, String])(implicit errors: mutable.ListBuffer[WaccError],
                                                                        symTable: mutable.Map[String, Type],
                                                                        funcTable: List[Func], source: String,
                                                                        waccLines: Array[String], funcName: Option[String]): RValue = {
    def checkPairElement(exp: Expr): Unit = checkType(exp) match {
      case PairType(_, _) =>
      case _: PairElemType =>
      case _ => semanticErrorOccurred("Invalid data type for element in newpair", exp.pos)
    }

    expr match {
      case exp: Expr => checkExpr(exp, varsInScope)
      case NewPair(exp1, exp2) =>
        val newExp1 = checkExpr(exp1, varsInScope)
        val newExp2 = checkExpr(exp2, varsInScope)
        checkPairElement(newExp1)
        checkPairElement(newExp2)

        new NewPair(newExp1, newExp2)(expr.pos)
      case Call(id, params) =>
        val newParams = params.map(checkExpr(_, varsInScope))
        val newId = Ident(waccPrefix + id.name)(id.pos)
        funcTable.find(x => x.ident.name == newId.name) match {
          case Some(funcCalled) =>
            if (funcCalled.paramList.length != newParams.length) {
              semanticErrorOccurred(s"Call to function ${id.name} has the incorrect number of arguments, expected ${funcCalled.paramList.length}, found ${newParams.length}", expr.pos)
            }
            (funcCalled.paramList zip newParams).foreach({ case (x, y) =>
              if (!sameType(x.typ, checkType(y))) {
                semanticErrorOccurred(s"Argument ${x.ident.name} in the call to function ${id.name} has the incorrect type. Expected ${x.typ}. Received ${checkType(y)}", y.pos)
              }
            })
          case None => semanticErrorOccurred(s"Unrecognised function identifier ${id.name}", id.pos)
        }
        new Call(newId, newParams)(expr.pos)
      case ArrayLit(elems) =>
        val newElems = elems.map(checkExpr(_, varsInScope))
        val arrayType = getArrayLitType(newElems)
        newElems.foreach(x =>
          if (!sameType(arrayType, checkType(x)))
            semanticErrorOccurred("Elements in array literal have different types", expr.pos))
        new ArrayLit(newElems)(expr.pos)
      case PairFst(value) => new PairFst(checkExpr(value, varsInScope))(expr.pos)
      case PairSnd(value) => new PairSnd(checkExpr(value, varsInScope))(expr.pos)
    }
  }

  // Check that other Expressions passed in as are syntactically sound according to the WACC specification
  private def checkExpr(expr: Expr, varsInScope: mutable.Map[String, String])(implicit errors: mutable.ListBuffer[WaccError],
                                                                      symTable: mutable.Map[String, Type],
                                                                      funcTable: List[Func], source: String,
                                                                      waccLines: Array[String], funcName: Option[String]): Expr = {
    expr match {
      case binOp: BinOpp => checkBinOp(binOp, varsInScope)
      case unOp: UnOpp => checkUnOp(unOp, varsInScope)
      case ArrayElem(id, indexes) =>
        checkArrayIndex(indexes, varsInScope) match {
          case Some((err, pos)) => semanticErrorOccurred(err, pos)
          case _ =>
        }
        val arrDim = getDimension(checkType(checkExpr(id: Expr, varsInScope)))
        if (arrDim < indexes.length && arrDim != 0) {
          semanticErrorOccurred(s"Array dimensions do not match: expected $arrDim , found ${indexes.length}", id.pos)
        }

        id match {
          case ArrayElem(_, _) =>
            checkExpr(id: Expr, varsInScope) match {
              case newId: Ident => new ArrayElem(newId, indexes)(expr.pos)
              case _ =>
                semanticErrorOccurred(s"Array identifier evaluates to the wrong type", id.pos)
                expr
            }
          case Ident(name) =>
            symTable.get(varsInScope.getOrElse(name, "")) match {
              case Some(value) => value match {
                case ArrayType(_) => createArrayElem(varsInScope(name), id.pos, indexes, expr.pos)
                case _ =>
                  semanticErrorOccurred(s"Attempting to access array element from non-array identifier $name", id.pos)
                  expr
              }
              case None =>
                expr
            }
        }
      case id@Ident(name) =>
        resolveIdentifier(name, varsInScope, id)
      case _ => expr
    }
  }

  private def resolveIdentifier(name: String, varsInScope: mutable.Map[String, String], id: Ident)(implicit errors: mutable.ListBuffer[WaccError], source: String,
                                                                                            waccLines: Array[String], funcName: Option[String]): Ident = {
    if (!varsInScope.contains(name)) {
      semanticErrorOccurred(s"Identifier not in scope: $name", id.pos)
      id
    } else {
      new Ident(varsInScope(name))(id.pos)
    }
  }


  // Check that Unary Operators are syntactically sound according to the WACC specification
  private def checkUnOp(expr: UnOpp, varsInScope: mutable.Map[String, String])(implicit errors: mutable.ListBuffer[WaccError],
                                                                       symTable: mutable.Map[String, Type],
                                                                       funcTable: List[Func], source: String,
                                                                       waccLines: Array[String], funcName: Option[String]): UnOpp = {
    val inside = checkExpr(expr.x, varsInScope)

    def returnsIntType(op: String): Unit = {
      checkType(inside) match {
        case IntType() =>
        case _ => semanticErrorOccurred(s"Argument $op is not of type ⟨int⟩, is type ${checkType(inside)}", inside.pos)
      }
    }

    def returnsCharType(op: String): Unit = {
      checkType(inside) match {
        case CharType() =>
        case _ => semanticErrorOccurred(s"Argument $op is not of type ⟨char⟩, is type ${checkType(inside)}", inside.pos)
      }
    }

    def returnsBoolType(op: String): Unit = {
      checkType(inside) match {
        case BoolType() =>
        case _ => semanticErrorOccurred(s"Argument $op is not of type ⟨bool⟩, is type ${checkType(inside)}", inside.pos)
      }
    }

    def returnsSeqType(op: String): Unit = {
      checkType(inside) match {
        case ArrayType(_) =>
        case StringType() =>
        case _ => semanticErrorOccurred(s"Argument $op is not of type ⟨string⟩, is type ${checkType(inside)}", inside.pos)
      }
    }

    expr match {
      case Chr(_) =>
        returnsIntType("chr")
        new Chr(inside)(expr.pos)
      case Len(_) =>
        returnsSeqType("len")
        new Len(inside)(expr.pos)
      case Neg(_) =>
        returnsIntType("neg")
        new Neg(inside)(expr.pos)
      case Not(_) =>
        returnsBoolType("!")
        new Not(inside)(expr.pos)
      case Ord(_) =>
        returnsCharType("ord")
        new Ord(inside)(expr.pos)
      case unOpp: UnOpp =>
        unOpp
    }
  }

  // Check that Binary Operators are syntactically sound according to the WACC specification
  private def checkBinOp(expr: BinOpp, varsInScope: mutable.Map[String, String])(implicit errors: mutable.ListBuffer[WaccError],
                                                                         symTable: mutable.Map[String, Type],
                                                                         funcTable: List[Func], source: String,
                                                                         waccLines: Array[String], funcName: Option[String]): BinOpp = {
    val newX = checkExpr(expr.x, varsInScope)
    val newY = checkExpr(expr.y, varsInScope)

    def returnsIntType(op: String): Unit = {
      checkType(newX) match {
        case IntType() =>
        case NoTypeExists =>
        case _ => semanticErrorOccurred(s"Left expression in $op is not of type ⟨int⟩, is ${checkType(newX)} instead", newX.pos)
      }
      checkType(newY) match {
        case IntType() =>
        case NoTypeExists =>
        case _ => semanticErrorOccurred(s"Right expression in $op is not of type ⟨int⟩, is ${checkType(newY)} instead", newY.pos)
      }
    }

    def returnsBoolType(op: String): Unit = {
      checkType(newX) match {
        case BoolType() =>
        case NoTypeExists =>
        case _ => semanticErrorOccurred(s"Left expression in $op is not of type ⟨bool⟩, is ${checkType(newX)} instead", newX.pos)
      }
      checkType(newY) match {
        case BoolType() =>
        case NoTypeExists =>
        case _ => semanticErrorOccurred(s"Right expression in $op is not of type ⟨bool⟩, is ${checkType(newY)} instead", newY.pos)
      }
    }

    def returnsIntOrCharType(op: String)(implicit funcName: Option[String]): Unit = {
      val exp1Typ = checkType(newX)
      exp1Typ match {
        case IntType() =>
        case CharType() =>
        case NoTypeExists =>
        case _ => semanticErrorOccurred(s"Left expression in $op is not of type ⟨int⟩ nor type ⟨char⟩, is ${checkType(newX)} instead", newX.pos)
      }
      val exp2Typ = checkType(newY)
      exp2Typ match {
        case IntType() =>
        case CharType() =>
        case NoTypeExists =>
        case _ => semanticErrorOccurred(s"Right expression in $op is not of type ⟨int⟩ nor type ⟨char⟩, is ${checkType(newY)} instead", newY.pos)
      }
      if (!sameType(exp1Typ, exp2Typ)) {
        semanticErrorOccurred(s"Two sides of $op has different types, left is of type $exp1Typ, right is of type $exp2Typ", expr.pos)
      }
    }

    def returnsSameType(op: String): Unit = {
      val exp1Typ = checkType(newX)
      val exp2Typ = checkType(newY)
      if (!sameType(exp1Typ, exp2Typ)) {
        semanticErrorOccurred(s"Two sides of $op has different types, left is of type $exp1Typ, right is of type $exp2Typ", expr.pos)
      }
    }

    expr match {
      case Sub(_, _) =>
        returnsIntType("subtraction")
        new Sub(newX, newY)(expr.pos)
      case Add(_, _) =>
        returnsIntType("addition")
        new Add(newX, newY)(expr.pos)
      case Mul(_, _) =>
        returnsIntType("multiplication")
        new Mul(newX, newY)(expr.pos)
      case Div(_, _) =>
        returnsIntType("division")
        new Div(newX, newY)(expr.pos)
      case Mod(_, _) =>
        returnsIntType("modulo")
        new Mod(newX, newY)(expr.pos)
      case GT(_, _) =>
        returnsIntOrCharType("\'>\'")
        new GT(newX, newY)(expr.pos)
      case GTE(_, _) =>
        returnsIntOrCharType("\'>=\'")
        new GTE(newX, newY)(expr.pos)
      case LT(_, _) =>
        returnsIntOrCharType("\'<\'")
        new LT(newX, newY)(expr.pos)
      case LTE(_, _) =>
        returnsIntOrCharType("\'<=\'")
        new LTE(newX, newY)(expr.pos)
      case Eq(_, _) =>
        returnsSameType("\'==\'")
        new Eq(newX, newY)(expr.pos)
      case NEq(_, _) =>
        returnsSameType("\'!=\'")
        new NEq(newX, newY)(expr.pos)
      case And(_, _) =>
        returnsBoolType("and operation")
        new And(newX, newY)(expr.pos)
      case Or(_, _) =>
        returnsBoolType("or operation")
        new Or(newX, newY)(expr.pos)
      case binOpp: BinOpp =>
        binOpp
    }
  }

  private def checkStatements(stats: List[Stat], varsInScope: mutable.Map[String, String], returnType: Type,
                              scopePrefix: String)(implicit errors: mutable.ListBuffer[WaccError],
                                           symTable: mutable.Map[String, Type],
                                           funcTable: List[Func], source: String,
                                           waccLines: Array[String]): List[Stat] = {

    var localSymTable: mutable.Map[String, String] = mutable.Map.empty[String, String]
    val newStats: mutable.ListBuffer[Stat] = mutable.ListBuffer.empty[Stat]
    var scopeIndex = 0
    implicit val funcName: Option[String] = Option(scopePrefix)

    for (stat <- stats) {
      val checkedStat: Stat = stat match {
        case Skip() => stat
        case Declaration(idType, id, value) =>
          val newValue = checkExpr(value, varsInScope ++ localSymTable)
          val newIdName = scopePrefix ++ id.name

          if (localSymTable.contains(id.name)) {
            semanticErrorOccurred(s"Variable named '${id.name}' is already defined", id.pos)
          } else if (!sameType(idType, checkType(newValue)) && checkType(newValue) != NoTypeExists) {
            semanticErrorOccurred(s"Type mismatch in declaration of ${id.name}: expected $idType, found ${checkType(newValue)}", stat.pos)
          }
          localSymTable = localSymTable.concat(Map(id.name -> newIdName))
          symTable += (newIdName -> idType)
          new Declaration(idType, new Ident(newIdName)(id.pos), newValue)(stat.pos)
        case Assign(lVal, rVal) =>
          val newLVal = checkExpr(lVal, varsInScope ++ localSymTable)
          val newRVal = checkExpr(rVal, varsInScope ++ localSymTable)

          if (!sameType(checkType(newLVal), checkType(newRVal)) && checkType(newLVal) != NoTypeExists) {
            semanticErrorOccurred(s"Type mismatch in assignment: expected ${checkType(newLVal)}, found ${checkType(newRVal)}", stat.pos)
          } else if (checkType(newLVal) == AnyType && checkType(newRVal) == AnyType) {
            semanticErrorOccurred("Types unclear on both sides of assignment", stat.pos)
          }
          new Assign(newLVal, newRVal)(stat.pos)
        case Read(expr) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)
          checkType(newExpr) match {
            case IntType() =>
            case CharType() =>
            case StringType() =>
            case _ => semanticErrorOccurred(s"Variable attempting read has incorrect type ${checkType(newExpr)}, can only be of type ⟨int⟩, ⟨char⟩ or ⟨string⟩", stat.pos)
          }
          new Read(newExpr)(stat.pos)
        case Free(expr) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)
          checkType(newExpr) match {
            case PairType(_, _) | ArrayType(_) =>
            case _ => semanticErrorOccurred(s"Only Pair and Array types can be freed, is type ${checkType(newExpr)}", stat.pos)
          }
          new Free(newExpr)(stat.pos)
        case Return(expr) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)
          if (returnType == null) {
            semanticErrorOccurred("Return statement outside of a function is not allowed", stat.pos)
          } else if (!sameType(checkType(newExpr), returnType) && checkType(newExpr) != NoTypeExists) {
            semanticErrorOccurred(s"Type mismatch in Return: expected $returnType, found ${checkType(expr)}", stat.pos)
          }
          new Return(newExpr)(stat.pos)
        case Exit(expr) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)
          checkType(newExpr) match {
            case IntType() =>
            case _ => semanticErrorOccurred(s"Exit code defined is not of type ⟨int⟩, is type ${checkType(newExpr)}", newExpr.pos)
          }
          new Exit(newExpr)(stat.pos)
        case Print(expr) => new Print(checkExpr(expr, varsInScope ++ localSymTable))(stat.pos)
        case Println(expr) => new Println(checkExpr(expr, varsInScope ++ localSymTable))(stat.pos)
        case If(expr, thenStat, elseStat) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)
          checkType(newExpr) match {
            case BoolType() =>
            case NoTypeExists =>
            case _ => semanticErrorOccurred("Condition for If statement is not of type ⟨bool⟩", expr.pos)
          }
          val newThenStat = checkStatements(thenStat, varsInScope ++ localSymTable, returnType, s"$scopePrefix${scopeIndex}if-then-")
          val newElseStat = checkStatements(elseStat, varsInScope ++ localSymTable, returnType, s"$scopePrefix${scopeIndex}if else-")
          scopeIndex += 1
          new If(newExpr, newThenStat, newElseStat)(stat.pos)
        case While(expr, whileBody) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)
          checkType(newExpr) match {
            case BoolType() =>
            case NoTypeExists =>
            case _ => semanticErrorOccurred("Condition for While statement is not of type ⟨bool⟩", expr.pos)
          }
          val newBody = checkStatements(whileBody, varsInScope ++ localSymTable, returnType, s"$scopePrefix${scopeIndex}while-")
          scopeIndex += 1
          new While(newExpr, newBody)(stat.pos)
        case Scope(body) =>
          val newBody = checkStatements(body, varsInScope ++ localSymTable, returnType, s"$scopePrefix%${scopeIndex}scope-")
          scopeIndex += 1
          new Scope(newBody)(stat.pos)
      }
      newStats += checkedStat
    }
    newStats.toList
  }

  def checkSemantics(inProg: Prog, file: String): (List[WaccError], Prog, mutable.Map[String, Type]) = {
    implicit val funcTable: List[Func] = inProg.funcs.map {
      case x@Func(funcType, id, params, funcStats) => new Func(funcType, Ident(waccPrefix + id.name)(id.pos), params, funcStats)(x.pos)
    }
    implicit val fileName: String = file
    val fileSource = Source.fromFile(new File(file))
    implicit val fileContents: Array[String] = fileSource.getLines().toArray
    fileSource.close()
    implicit val symTable: mutable.Map[String, Type] = mutable.LinkedHashMap[String, Type]()
    implicit val errors: mutable.ListBuffer[WaccError] = mutable.ListBuffer.empty[WaccError]
    implicit val mainScope: Option[String] = Option.empty

    var tempFuncTable: List[Func] = Nil
    val newFuncs = funcTable.map(x => {
      if (tempFuncTable.exists(y => y.ident.name == x.ident.name)) {
        semanticErrorOccurred(s"Duplicated function declaration: ${x.ident.name.replace(waccPrefix, "")}", x.pos)
      } else {
        tempFuncTable = tempFuncTable :+ x
      }
      var argList: List[Param] = Nil
      x.paramList.foreach(a => if (argList.exists(b => a.ident.name == b.ident.name)) {
        semanticErrorOccurred(s"Duplicated function argument ${a.ident.name.replace(waccPrefix, "")} in function ${x.ident.name.replace(waccPrefix, "")}", a.pos)
      } else {
        argList = argList :+ a
      })
      val funcScopePrefix = s"func-${x.ident.name}-"
      x.paramList.foreach(y => symTable += (funcScopePrefix ++ "param-" ++ y.ident.name) -> y.typ)

      val mBuilder = mutable.Map.newBuilder[String, String]
      mBuilder ++= x.paramList.map(y => y.ident.name -> (funcScopePrefix ++ "param-" ++ y.ident.name))
      val m: mutable.Map[String, String] = mBuilder.result()

      new Func(x.typ, x.ident, x.paramList,
        checkStatements(x.stats, m, x.typ, funcScopePrefix))(x.pos)
    })
    val newProg = new Prog(newFuncs, checkStatements(inProg.stats, mutable.Map.empty, null, "main-"))(inProg.pos) // still mutable
    (errors.toList, newProg, symTable)
  }
}
