package frontend

import frontend.ast._
import frontend.waccErrors.{SemanticError, WaccError}

import java.io.File
import scala.annotation.tailrec
import scala.collection.mutable
import scala.collection.mutable.ListBuffer
import scala.io.Source

object validator {

  // Tuple representing a null position in a source file
  private val nullPos: (Int, Int) = (-1, -1)
  // Prefix used for generated WACC code
  val waccPrefix = "wacc_"
  private var globalFilename: String = _
  private var globalScopePrefix: String = _

  // Function to determine if two types are the same or similar after certain type transformations
  private def sameType(t1: Type, t2: Type): Boolean = {
    // Check if types are equal
    if (t1 == t2) {
      true
    } else (t1, t2) match {
      // Check for specific type transformations that result in different types
      case (ArrayType(StringType()), ArrayType(ArrayType(CharType()))) => false
      case (ArrayType(arrType1), ArrayType(arrType2)) => sameType(arrType1, arrType2)

      case (PairType(StringType(), _), PairType(ArrayType(CharType()), _)) => false
      case (PairType(_, StringType()), PairType(_, ArrayType(CharType()))) => false
      case (PairType(t1l, t1r), PairType(t2l, t2r)) => sameType(t1l, t2l) && sameType(t1r, t2r)

      case (PairType(_, _), Pair()) => true
      case (Pair(), PairType(_, _)) => true
      case (StringType(), ArrayType(CharType())) => true
      // Check if either type is of AnyType, which can match any other type
      case _ => t1 == AnyType || t2 == AnyType
    }
  }

  // Add to the errors generated by a WACC file after compilation to be returned to the user
  private def semanticErrorOccurred(reason: String, pos: (Int, Int))(implicit errors: mutable.ListBuffer[WaccError], source: String, waccLines: Array[String], scopePrefix: Option[String]): Unit = {
    errors += SemanticError.genError(reason, pos)
  }

  // Function to check if any expression passed in as an LValue is of or contains the expected type(s)
  private def checkType(expr: LValue)(implicit symTable: mutable.Map[String, Type]): Type = {

    // Helper function to handle operations on pairs (first or second element)
    def pairOperation(value: LValue, isFirst: Boolean): Type = checkType(value) match {
      case Pair() => AnyType
      case PairType(fst, snd) => if (isFirst) fst else snd
      case _ => NoTypeExists
    }

    // Match the LValue expression and return the corresponding type
    expr match {
      // If it's an identifier, get its type from the symbol table
      case Ident(name) =>
        var checkedName = name
        if (!checkedName.contains("-")) {
          checkedName = globalScopePrefix + checkedName
        }
        symTable.getOrElse(checkedName, NoTypeExists)
      // If it's an array element, get the type of the array
      case ArrayElem(id: Ident, exprs) => removeArrayWrapper(checkType(Ident(globalScopePrefix++id.name)(id.pos): Expr), exprs.length)
      // If it's a pair first element, get the type of the first element
      case PairFst(value) => pairOperation(value, isFirst = true)
      // If it's a pair second element, get the type of the second element
      case PairSnd(value) => pairOperation(value, isFirst = false)
    }
  }


  // Function to check the type of a new pair expression
  private def checkNewPair(exp1: Expr, exp2: Expr)(implicit symTable: mutable.Map[String, Type]): PairType = {

    // Helper function to resolve the type of a pair element
    def resolvePairType(expr: Expr): PairElemType = checkType(expr) match {
      case PairType(_, _) => Pair()(nullPos)
      case pairType: PairElemType => pairType
      case _ => NoTypeExists
    }

    // Get the type of the first and second expressions
    val exp1Type: PairElemType = resolvePairType(exp1)
    val exp2Type: PairElemType = resolvePairType(exp2)

    // Return the PairType with the resolved types of the expressions
    PairType(exp1Type, exp2Type)(null)
  }


  // Function to check the type of an RValue expression
  def checkType(expr: RValue)(implicit symTable: mutable.Map[String, Type], funcTable: List[Func]): Type = expr match {
    // If the expression is an Expr, recursively check its type
    case exp: Expr => checkType(exp)

    // If the expression is a NewPair, check its type using checkNewPair function
    case NewPair(exp1, exp2) =>
      checkNewPair(exp1, exp2)

    // If the expression is a Call, find the corresponding function in the function table and return its type
    case Call(ident, _) => funcTable.find(x => x.ident.name == ident.name) match {
      case Some(value) => value.typ.getOrElse(AnyType)
      case None => NoTypeExists
    }

    // If the expression is PairFst or PairSnd, check the type of the inner expression and return the pair element type
    case PairFst(value) => checkType(value) match {
      case Pair() => AnyType
      case PairType(pairTyp, _) => pairTyp
      case _ => NoTypeExists
    }
    case PairSnd(value) => checkType(value) match {
      case Pair() => AnyType
      case PairType(_, pairTyp) => pairTyp
      case _ => NoTypeExists
    }

    // If the expression is an ArrayLit, check its type using getArrayLitType function
    case ArrayLit(elems) => if (elems.isEmpty) ArrayType(AnyType)(nullPos) else {
      ArrayType(getArrayLitType(elems))(nullPos)
    }
  }


  // Function to determine the type of an array literal based on its elements
  private def getArrayLitType(elems: List[Expr])(implicit symTable: mutable.Map[String, Type]): Type = {
    // If the list of elements is empty, return NoTypeExists as there is no type information
    if (elems.isEmpty) {
      NoTypeExists
    } else {
      // Map each expression to its type using checkType function
      val arrayElementTypes: List[Type] = elems.map(checkType)

      // If the array contains StringType elements, return StringType
      if (arrayElementTypes.contains(StringType()(nullPos))) {
        StringType()(nullPos)
      } else {
        // Otherwise, return the type of the first element
        arrayElementTypes.head
      }
    }
  }


  // Function to check the type of expressions involved in binary or unary operations
  def checkType(expr: Expr)(implicit symTable: mutable.Map[String, Type]): Type = {
    expr match {
      // Arithmetic binary operations return IntType
      case Sub(_, _) | Add(_, _) | Mul(_, _) | Div(_, _) | Mod(_, _) => IntType()(nullPos)

      // Comparison binary operations return BoolType
      case GT(_, _) | GTE(_, _) | LT(_, _) | LTE(_, _) | Eq(_, _) | NEq(_, _) => BoolType()(nullPos)

      // Logical binary operations return BoolType
      case And(_, _) | Or(_, _) => BoolType()(nullPos)

      // Unary operations return IntType or CharType or BoolType depending on the operation
      case Plus(_) => IntType()(nullPos)
      case Not(_) => BoolType()(nullPos)
      case Len(_) | Neg(_) | Ord(_) => IntType()(nullPos)
      case Chr(_) => CharType()(nullPos)

      // Array element access returns the type of the elements inside the array
      case ArrayElem(id, exprs) => removeArrayWrapper(checkType(id: Expr), exprs.length)

      // Literal expressions return their corresponding types
      case BoolLit(_) => BoolType()(nullPos)
      case IntLit(_) => IntType()(nullPos)
      case CharLit(_) => CharType()(nullPos)
      case StrLit(_) => StringType()(nullPos)
      case PairLiter() => AnyType

      // Identifiers return their type from the symbol table or NoTypeExists if not found
      case Ident(checkName) =>
        var name = checkName
        if (!checkName.contains("-")) {
          name = globalScopePrefix + name
        }
        val newIdName = name.substring(name.lastIndexOf("-") + 1)
        val identCheck = isDeclaredOutside(name, symTable.keys.toList)
        if (identCheck._2) {
          symTable.getOrElse(identCheck._1.get + newIdName, NoTypeExists)
        } else {
          symTable.getOrElse(identCheck._1.get + newIdName, NoTypeExists)
        }

      // Atomic expressions, unary operations, and binary operations are not directly supported and return NoTypeExists
      case _: Atom | _: UnOpp | _: BinOpp => NoTypeExists
    }
  }

  def isDeclaredOutside(newIdName: String, scopedVars: List[String]): (Option[String], Boolean) = {
    // Check if a variable with the same ident has been declared previously and get its index if so
    val splitIndex = newIdName.lastIndexOf("-") + 1
    val name = newIdName.substring(splitIndex)
    val nameScope = newIdName.substring(0, splitIndex)
    val sameNameIndices = scopedVars.zipWithIndex.filter(p => {
      p._1.substring(p._1.lastIndexOf("-") + 1) == name
    }).map(p => p._2)

    // Check if it was declared in an outer scope
    val result = sameNameIndices.map(i => {
      var isParam = false
      var preParam = scopedVars(i).substring(0, scopedVars(i).lastIndexOf("-") + 1)
      if (preParam.contains("param-")) {
        isParam = true
        preParam = preParam.replace("param-", "")
      }
      (preParam, isParam)
    })
//    val scopeCheckFunc: String => Boolean =
    var scopeFound = result.find(sv => nameScope.contains(sv._1))
    if (scopeFound.getOrElse(("", false))._2) {
      scopeFound = Option(scopeFound.get._1 + "param-", scopeFound.get._2)
    }
    val resultScope = Option(scopeFound.getOrElse("", false)._1)
    (resultScope, resultScope.get != "")
  }

  @tailrec
  private def removeArrayWrapper(typ: Type, dimensions: Int)(implicit symTable: mutable.Map[String, Type]): Type = {
    if (dimensions <= 0) {
      typ
    } else {
      typ match {
        case ArrayType(arrTyp) => removeArrayWrapper(arrTyp, dimensions - 1)
        case _ => NoTypeExists
      }
    }
  }

  // Creates a new array element
  private def createArrayElem(name: String, idPos: (Int, Int), indexes: List[Expr], exprPos: (Int, Int)): ArrayElem = {
    new ArrayElem(new Ident(name)(idPos), indexes)(exprPos)
  }


  // Function to check the syntactic correctness of expressions representing l-values according to the WACC specification
  private def checkExpr(expr: LValue, varsInScope: mutable.Map[String, String])
                       (implicit errors: mutable.ListBuffer[WaccError],
                        symTable: mutable.Map[String, Type],
                        funcTable: List[Func],
                        source: String,
                        waccLines: Array[String],
                        funcName: Option[String]): LValue = {
    expr match {
      // Identifier: Resolve the identifier and return the corresponding l-value
      case id@Ident(name) =>
        resolveIdentifier(name, varsInScope, id)
      // Array Element: Check array index, then check if the array identifier evaluates to correct type
      case ArrayElem(id, indexes) =>
        checkArrayIndex(indexes, varsInScope) match {
          case Some((err, pos)) => semanticErrorOccurred(err, pos)
          case _ =>
        }
        id match {
          case ArrayElem(_, _) =>
            checkExpr(id: Expr, varsInScope) match {
              case newId: Ident => new ArrayElem(newId, indexes)(expr.pos)
              case _ =>
                semanticErrorOccurred(s"Array identifier evaluates to incorrect type: $id", id.pos)
                expr
            }
          case Ident(name) =>
            symTable.get(varsInScope.getOrElse(name, "")) match {
              case Some(value) => value match {
                case ArrayType(_) => createArrayElem(varsInScope(name), id.pos, indexes, expr.pos)
                case _ =>
                  semanticErrorOccurred(s"Attempting to access array element from non-array identifier: $name", id.pos)
                  expr
              }
              case None =>
                semanticErrorOccurred(s"Identifier not in scope: $name", id.pos)
                expr
            }
        }
      // Pair First: Recursively check the value expression and return PairFst l-value
      case PairFst(value) => new PairFst(checkExpr(value, varsInScope))(expr.pos)
      // Pair Second: Recursively check the value expression and return PairSnd l-value
      case PairSnd(value) => new PairSnd(checkExpr(value, varsInScope))(expr.pos)
    }
  }

  // Function to check the syntactic correctness of array indexes according to the WACC specification
  private def checkArrayIndex(exprs: List[Expr], varsInScope: mutable.Map[String, String])
                             (implicit errors: mutable.ListBuffer[WaccError],
                              symTable: mutable.Map[String, Type],
                              funcTable: List[Func],
                              source: String,
                              waccLines: Array[String],
                              funcName: Option[String]): Option[(String, (Int, Int))] = {
    for (expr <- exprs) {
      // Check each expression in the list of indexes
      val newExpr = checkExpr(expr, varsInScope)
      checkType(newExpr)(symTable) match {
        // If the expression type is Int, continue to the next expression
        case IntType() =>
        // If the expression type is not Int, return an error message with the position
        case _ => return Option("Array Indexes must be of type <int>", expr.pos)
      }
    }
    // If all expressions in the list are of type Int, return None (no errors found)
    None
  }

  // Finds the dimension of an array
  private def getDimension(array:Type): Int = {
    array match {
      case ArrayType(x) => 1 + getDimension(x)
      case _ => 0
    }
  }

  // Function to check the syntactic correctness of an expression in the context of an RValue according to the WACC specification
  private def checkExpr(expr: RValue, varsInScope: mutable.Map[String, String])
                       (implicit errors: mutable.ListBuffer[WaccError],
                        symTable: mutable.Map[String, Type],
                        funcTable: List[Func],
                        source: String,
                        waccLines: Array[String],
                        funcName: Option[String]): RValue = {
    // Function to check if the element of a Pair expression is syntactically correct
    def checkPairElement(exp: Expr): Unit = checkType(exp) match {
      case PairType(_, _) =>
      case _: PairElemType =>
      case _ => semanticErrorOccurred("Invalid data type for element in newpair", exp.pos)
    }

    expr match {
      // If the expression is an Expr, check its syntactic correctness recursively
      case exp: Expr => checkExpr(exp, varsInScope)
      case NewPair(exp1, exp2) =>
        // Check the syntactic correctness of each expression in the NewPair construct
        val newExp1 = checkExpr(exp1, varsInScope)
        val newExp2 = checkExpr(exp2, varsInScope)
        // Check if each expression is syntactically correct for a Pair
        checkPairElement(newExp1)
        checkPairElement(newExp2)
        // Return a new NewPair expression with the corrected expressions
        new NewPair(newExp1, newExp2)(expr.pos)
      case Call(id, params) =>
        // Create a new identifier with the WACC prefix for the function name
        val newId = Ident(waccPrefix + id.name)(id.pos)
        var newParams: List[Expr] = List.empty
        val funcFound = funcTable.find(x => x.ident.name == newId.name)
        if (funcFound.isEmpty) {
          semanticErrorOccurred("Call to an undefined function: " + id.name, id.pos)
        } else {
          val noTypeIndices = funcFound.get.paramList.zipWithIndex.filter(p => p._1.typ.getOrElse(NoType) == NoType).map(p => p._2)
          val paramTypes = params.map(param => checkType(param))

          // Assign inferred parameter types for those that are not known
          noTypeIndices.foreach(ind => funcFound.get.paramList(ind).typ = Option(paramTypes(ind)))
          // Update symbol table with new parameter types
          funcFound.get.paramList.foreach(p => {
            val funcParamName = s"func-${newId.name}-param-${p.ident.name}"
            symTable += funcParamName -> p.typ.getOrElse(NoType)
          })

          // Now try to infer the function return type from the new parameter types
          val inferredFuncType = inferFuncReturnType(newId, funcFound.get.stats, globalFilename, symTable, funcTable)
          funcFound.get.typ = Option(inferredFuncType)
          // Check the syntactic correctness of each parameter in the function call
          newParams = params.map(checkExpr(_, varsInScope))

          // Find the function definition in the function table
          funcFound match {
            case Some(funcCalled) =>
              // Check if the number of arguments matches the number of parameters in the function definition
              if (funcCalled.paramList.length != newParams.length) {
                semanticErrorOccurred(s"Call to function ${id.name} has the incorrect number of arguments, expected ${funcCalled.paramList.length}, found ${newParams.length}", expr.pos)
              }
              // Check if the types of arguments match the types of parameters in the function definition
              (funcCalled.paramList zip newParams).foreach({ case (x, y) =>
                if (!sameType(x.typ.getOrElse(NoTypeExists), checkType(y))) {
                  semanticErrorOccurred(s"Argument ${x.ident.name} in the call to function ${id.name} has the incorrect type. Expected ${x.typ}. Received ${checkType(y)}", y.pos)
                }
              })
            case None => semanticErrorOccurred(s"Unrecognised function identifier ${id.name}", id.pos)
          }
        }
        // Return a new Call expression with the corrected parameters
        new Call(newId, newParams)(expr.pos)
      case ArrayLit(elems) =>
        // Check the syntactic correctness of each element in the array literal
        val newElems = elems.map(checkExpr(_, varsInScope))
        // Get the type of the array literal
        val arrayType = getArrayLitType(newElems)
        // Check if each element has the same type as the array literal
        newElems.foreach(x =>
          if (!sameType(arrayType, checkType(x)))
            semanticErrorOccurred("Elements in array literal have different types", expr.pos))
        // Return a new ArrayLit expression with the corrected elements
        new ArrayLit(newElems)(expr.pos)
      case PairFst(value) => new PairFst(checkExpr(value, varsInScope))(expr.pos)
      case PairSnd(value) => new PairSnd(checkExpr(value, varsInScope))(expr.pos)
    }
  }

  // Function to check the syntactic correctness of other expressions according to the WACC specification
  private def checkExpr(expr: Expr, varsInScope: mutable.Map[String, String])
                       (implicit errors: mutable.ListBuffer[WaccError],
                        symTable: mutable.Map[String, Type],
                        funcTable: List[Func],
                        source: String,
                        waccLines: Array[String],
                        funcName: Option[String]): Expr = {
    expr match {
      // If the expression is a binary operation, check its syntactic correctness
      case binOp: BinOpp => checkBinOp(binOp, varsInScope)
      // If the expression is a unary operation, check its syntactic correctness
      case unOp: UnOpp => checkUnOp(unOp, varsInScope)
      // If the expression is an ArrayElem
      case ArrayElem(id, indexes) =>
        // Check the syntactic correctness of the array indexes
        checkArrayIndex(indexes, varsInScope) match {
          case Some((err, pos)) => semanticErrorOccurred(err, pos)
          case _ =>
        }
        // Get the dimension of the array
        val arrDim = getDimension(checkType(checkExpr(id: Expr, varsInScope)))
        // Check if the number of indexes matches the dimension of the array
        if (arrDim < indexes.length && arrDim != 0) {
          semanticErrorOccurred(s"Array dimensions do not match: expected $arrDim , found ${indexes.length}", id.pos)
        }

        id match {
          case ArrayElem(_, _) =>
            checkExpr(id: Expr, varsInScope) match {
              case newId: Ident => new ArrayElem(newId, indexes)(expr.pos)
              case _ =>
                semanticErrorOccurred(s"Array identifier evaluates to the wrong type", id.pos)
                expr
            }
          case Ident(name) =>
            symTable.get(varsInScope.getOrElse(name, "")) match {
              case Some(value) => value match {
                case ArrayType(_) => createArrayElem(varsInScope(name), id.pos, indexes, expr.pos)
                case _ =>
                  semanticErrorOccurred(s"Attempting to access array element from non-array identifier $name", id.pos)
                  expr
              }
              case None =>
                expr
            }
        }
      // If the expression is an identifier, resolve it
      case id@Ident(name) =>
        resolveIdentifier(name, varsInScope, id)
      // For other expressions, return as is
      case _ => expr
    }
  }


  // Resolves an identifier within the given scope, ensuring it is in scope.
  // If the identifier is not found in the scope, a semantic error is recorded.
  private def resolveIdentifier(name: String, varsInScope: mutable.Map[String, String], id: Ident)
                               (implicit errors: mutable.ListBuffer[WaccError],
                                source: String,
                                waccLines: Array[String],
                                funcName: Option[String]): Ident = {
    // Check if the identifier exists in the current scope
    if (!varsInScope.contains(name)) {
      // Record a semantic error if the identifier is not in scope
      semanticErrorOccurred(s"Identifier not in scope: $name", id.pos)
      id // Return the original identifier
    } else {
      // Return a new identifier object with the value from the scope
      new Ident(varsInScope(name))(id.pos)
    }
  }


  // Checks unary operators for syntactic correctness according to the WACC specification.
  private def checkUnOp(expr: UnOpp, varsInScope: mutable.Map[String, String])
                       (implicit errors: mutable.ListBuffer[WaccError],
                        symTable: mutable.Map[String, Type],
                        funcTable: List[Func],
                        source: String,
                        waccLines: Array[String],
                        funcName: Option[String]): UnOpp = {
    // Check the expression inside the unary operator
    val inside = checkExpr(expr.x, varsInScope)

    // Helper functions to check if the expression inside the unary operator has the expected type
    def returnsIntType(op: String): Unit = {
      checkType(inside) match {
        case IntType() => // No error if the type is int
        case _ => semanticErrorOccurred(s"Argument $op is not of type <int>, is type ${checkType(inside)}", inside.pos)
      }
    }

    def returnsCharType(op: String): Unit = {
      checkType(inside) match {
        case CharType() => // No error if the type is char
        case _ => semanticErrorOccurred(s"Argument $op is not of type <char>, is type ${checkType(inside)}", inside.pos)
      }
    }

    def returnsBoolType(op: String): Unit = {
      checkType(inside) match {
        case BoolType() => // No error if the type is bool
        case _ => semanticErrorOccurred(s"Argument $op is not of type <bool>, is type ${checkType(inside)}", inside.pos)
      }
    }

    def returnsSeqType(op: String): Unit = {
      checkType(inside) match {
        case ArrayType(_) => // No error if the type is array
        case StringType() => // No error if the type is string
        case _ => semanticErrorOccurred(s"Argument $op is not of type <string>, is type ${checkType(inside)}", inside.pos)
      }
    }

    // Check each unary operator type and validate its argument type
    expr match {
      case Chr(_) =>
        returnsIntType("chr")
        new Chr(inside)(expr.pos)
      case Len(_) =>
        returnsSeqType("len")
        new Len(inside)(expr.pos)
      case Neg(_) =>
        returnsIntType("neg")
        new Neg(inside)(expr.pos)
      case Not(_) =>
        returnsBoolType("!")
        new Not(inside)(expr.pos)
      case Ord(_) =>
        returnsCharType("ord")
        new Ord(inside)(expr.pos)
      case unOpp: UnOpp =>
        unOpp // Return the original unary operator expression
    }
  }

  // Checks binary operators for syntactic correctness according to the WACC specification.
  private def checkBinOp(expr: BinOpp, varsInScope: mutable.Map[String, String])
                        (implicit errors: mutable.ListBuffer[WaccError],
                         symTable: mutable.Map[String, Type],
                         funcTable: List[Func],
                         source: String,
                         waccLines: Array[String],
                         funcName: Option[String]): BinOpp = {
    // Check the expressions on both sides of the binary operator
    val newX = checkExpr(expr.x, varsInScope)
    val newY = checkExpr(expr.y, varsInScope)

    // Helper functions to check if the expressions on both sides have the expected types for each binary operator
    def returnsIntType(op: String): Unit = {
      // Check if the left expression is of type int
      checkType(newX) match {
        case IntType() => // No error if the type is int
        case NoTypeExists => // No error if the type is not available
        case _ => semanticErrorOccurred(s"Left expression in $op is not of type <int>, is ${checkType(newX)} instead", newX.pos)
      }
      // Check if the right expression is of type int
      checkType(newY) match {
        case IntType() => // No error if the type is int
        case NoTypeExists => // No error if the type is not available
        case _ => semanticErrorOccurred(s"Right expression in $op is not of type <int>, is ${checkType(newY)} instead", newY.pos)
      }
    }

    def returnsBoolType(op: String): Unit = {
      // Check if the left expression is of type bool
      checkType(newX) match {
        case BoolType() => // No error if the type is bool
        case NoTypeExists => // No error if the type is not available
        case _ => semanticErrorOccurred(s"Left expression in $op is not of type <bool>, is ${checkType(newX)} instead", newX.pos)
      }
      // Check if the right expression is of type bool
      checkType(newY) match {
        case BoolType() => // No error if the type is bool
        case NoTypeExists => // No error if the type is not available
        case _ => semanticErrorOccurred(s"Right expression in $op is not of type <bool>, is ${checkType(newY)} instead", newY.pos)
      }
    }

    def returnsIntOrCharType(op: String)(implicit funcName: Option[String]): Unit = {
      // Check if the left expression is of type int or char
      val exp1Typ = checkType(newX)
      exp1Typ match {
        case IntType() => // No error if the type is int
        case CharType() => // No error if the type is char
        case NoTypeExists => // No error if the type is not available
        case _ => semanticErrorOccurred(s"Left expression in $op is not of type <int> nor type <char>, is ${checkType(newX)} instead", newX.pos)
      }
      // Check if the right expression is of type int or char
      val exp2Typ = checkType(newY)
      exp2Typ match {
        case IntType() => // No error if the type is int
        case CharType() => // No error if the type is char
        case NoTypeExists => // No error if the type is not available
        case _ => semanticErrorOccurred(s"Right expression in $op is not of type <int> nor type <char>, is ${checkType(newY)} instead", newY.pos)
      }
      // Check if both sides have the same type
      if (!sameType(exp1Typ, exp2Typ)) {
        semanticErrorOccurred(s"Two sides of $op have different types, left is of type $exp1Typ, right is of type $exp2Typ", expr.pos)
      }
    }

    def returnsSameType(op: String): Unit = {
      // Check if both sides have the same type
      val exp1Typ = checkType(newX)
      val exp2Typ = checkType(newY)
      if (!sameType(exp1Typ, exp2Typ)) {
        semanticErrorOccurred(s"Two sides of $op have different types, left is of type $exp1Typ, right is of type $exp2Typ", expr.pos)
      }
    }

    // Check each binary operator type and validate its argument types
    expr match {
      case Sub(_, _) =>
        returnsIntType("subtraction")
        new Sub(newX, newY)(expr.pos)
      case Add(_, _) =>
        returnsIntType("addition")
        new Add(newX, newY)(expr.pos)
      case Mul(_, _) =>
        returnsIntType("multiplication")
        new Mul(newX, newY)(expr.pos)
      case Div(_, _) =>
        returnsIntType("division")
        new Div(newX, newY)(expr.pos)
      case Mod(_, _) =>
        returnsIntType("modulo")
        new Mod(newX, newY)(expr.pos)
      case GT(_, _) =>
        returnsIntOrCharType("\'>\'")
        new GT(newX, newY)(expr.pos)
      case GTE(_, _) =>
        returnsIntOrCharType("\'>=\'")
        new GTE(newX, newY)(expr.pos)
      case LT(_, _) =>
        returnsIntOrCharType("\'<\'")
        new LT(newX, newY)(expr.pos)
      case LTE(_, _) =>
        returnsIntOrCharType("\'<=\'")
        new LTE(newX, newY)(expr.pos)
      case Eq(_, _) =>
        returnsSameType("\'==\'")
        new Eq(newX, newY)(expr.pos)
      case NEq(_, _) =>
        returnsSameType("\'!=\'")
        new NEq(newX, newY)(expr.pos)
      case And(_, _) =>
        returnsBoolType("and operation")
        new And(newX, newY)(expr.pos)
      case Or(_, _) =>
        returnsBoolType("or operation")
        new Or(newX, newY)(expr.pos)
      case binOpp: BinOpp =>
        binOpp // Return the original binary operator expression
    }
  }

  @tailrec
  private def identFromIdentArray(identArray: IdentArray): String = {
    identArray match {
      case Ident(name) =>
        name
      case ArrayElem(elem, _) =>
        identFromIdentArray(elem)
    }
  }

  @tailrec
  private def identFromPairElem(pairElem: LValue): String = {
    pairElem match {
      case Ident(name) =>
        name
      case PairFst(fst) =>
        identFromPairElem(fst)
      case PairSnd(snd) =>
        identFromPairElem(snd)
    }
  }

  // Checks a list of statements for syntactic correctness according to the WACC specification.
  private def checkStatements(stats: List[Stat],
                              varsInScope: mutable.Map[String, String],
                              returnType: Type,
                              scopePrefix: String)
                             (implicit errors: mutable.ListBuffer[WaccError],
                              symTable: mutable.Map[String, Type],
                              funcTable: List[Func],
                              source: String,
                              waccLines: Array[String]): List[Stat] = {

    // Local symbol table to keep track of variables declared within the current scope
    var localSymTable: mutable.Map[String, String] = mutable.Map.empty[String, String]
    // Buffer to store the checked statements
    val newStats: mutable.ListBuffer[Stat] = mutable.ListBuffer.empty[Stat]
    // Index to generate unique scope prefixes
    var scopeIndex = 0
    implicit val funcName: Option[String] = Option(scopePrefix)

    /* returns true if the lvalue isn't declared yet */
    def isInferredTypeDef(lVal: LValue, newIdName: String, scopedVars: List[String]): Boolean = {

      lVal match {

        /* if its an identifier then check if its in the parent and child scope maps yet */
        case Ident(name) =>

          !localSymTable.values.exists(_ == name) && !localSymTable.contains(name) && !isDeclaredOutside(newIdName, scopedVars)._2
        case _ => false
      }
    }

    def isTypelessParam(lVal: LValue): Boolean = {
      lVal match {
        case Ident(name) =>
          if (!localSymTable.values.exists(_ == name) && !localSymTable.contains(name)) {
            false
          } else {
            checkType(lVal) == NoType
          }
        case _ => false
      }
    }

    def pairElemToFullType(rVal: RValue, isFst: Boolean): PairElemType = {
      var fullElemType: PairElemType = AnyType

          rVal match {
            case NewPair(npFst: Expr, npSnd: Expr) =>
              var tempElemType: Type = AnyType
              if (isFst) {
                tempElemType = checkType(npFst)
              } else {
                tempElemType = checkType(npSnd)
              }
              tempElemType match {
                case pElem: PairElemType =>
                  fullElemType = pElem
                // Should never be reached
                case _ =>
              }
            case Ident(name) =>
              val tempElemType = symTable(localSymTable(name))
              tempElemType match {
                case pElem: PairElemType =>
                  pElem match {
                    case PairType(fst, snd) =>
                      if (isFst) {
                        fullElemType = fst
                      } else {
                        fullElemType = snd
                      }
                    case _ =>
                      fullElemType = pElem
                  }
                // Should never be reached
                case _ =>
              }
            case pf@PairFst(_) =>
              fullElemType = fullInnerPairElem(pf, isFst)
            case ps@PairSnd(_) =>
              fullElemType = fullInnerPairElem(ps, isFst)
            case arrElem@ArrayElem(_, _) =>
              fullElemType = fullInnerPairElem(arrElem, isFst)

            case Call(x, _) =>
              val funcCalled = funcTable.find(f => f.ident.name == waccPrefix + x)
              funcCalled match {
                case Some(called) =>
                  val returnType = inferFuncReturnType(called.ident, called.stats, globalFilename, symTable, funcTable)
                  returnType match {
                    case checkPType: PairElemType =>
                      fullElemType = checkPType
                    case _ =>
                  }
                case None =>
              }
            case _ =>
          }
      fullElemType
    }

    def fullInnerPairElem(lVal: LValue, isFst: Boolean): PairElemType = {
      lVal match {
        case id@Ident(_) =>
          pairElemToFullType(id, isFst)
        case PairFst(pf) =>
          fullInnerPairElem(pf, isFst) match {
            case elemType: PairElemType =>
              elemType match {
                case PairType(fst, _) =>
                  fst
                case _ =>
                  elemType
              }

          }
        case PairSnd(ps) =>
          fullInnerPairElem(ps, isFst) match {
            case elemType: PairElemType =>
              elemType match {
                case PairType(_, snd) =>
                  snd
                case _ =>
                  elemType
              }
          }
        case ArrayElem(identArray, exprs) =>
          val arrIdent = identFromIdentArray(identArray)
          val arrType: Type = removeArrayWrapper(checkType(lVal), exprs.length)
          arrType match {
            case _: PairElemType =>
              fullInnerPairElem(Ident(arrIdent)(identArray.pos), isFst)
            case _ =>
              AnyType
          }
        case _ =>
          // Will never reach here
          AnyType
      }
    }

    def toFullPair(typ: PairType, rVal: RValue): PairType = {
      // Check for setting to null pair
      rVal match {
        case PairLiter() =>
          typ
        case _ =>
          typ match {
            case PairType(_, _) =>
              PairType(pairElemToFullType(rVal, isFst = true), pairElemToFullType(rVal, isFst = false))(typ.pos)
            case _ =>
              typ
          }
      }
    }

    def checkStatement(stat: Stat) = {
      val checkedStat: Stat = stat match {
        case Skip() => stat // No action needed for Skip statement
        case Declaration(idType, id, value) =>

          var newIdType = idType
          idType match {
            case p@PairType(_, _) =>
                globalScopePrefix = scopePrefix
                newIdType = toFullPair(p, value)
            case _ =>
          }

          val newValue = checkExpr(value, varsInScope ++ localSymTable)
          val newIdName = scopePrefix ++ id.name

          // Check for variable redeclaration
          if (localSymTable.contains(id.name)) {
            semanticErrorOccurred(s"Variable named '${id.name}' is already defined", id.pos)
          } else if (!sameType(idType, checkType(newValue)) && checkType(newValue) != NoTypeExists) {
            semanticErrorOccurred(s"Type mismatch in declaration of ${id.name}: expected $idType, found ${checkType(newValue)}", stat.pos)
          }

          // Add the variable to the local symbol table and the global symbol table
          localSymTable = localSymTable.concat(Map(id.name -> newIdName))
          symTable += (newIdName -> newIdType)
          new Declaration(idType, new Ident(newIdName)(id.pos), newValue)(stat.pos)

        case AssignorInferDecl(lVal, rVal) =>
          val newRVal = checkExpr(rVal, varsInScope ++ localSymTable)

          var lType: Type = NoTypeExists
          var rType: Type = NoTypeExists

          lVal match {
            case id@Ident(name) =>
              if (funcTable.map(func => func.ident.name).contains(waccPrefix + name) && !varsInScope.contains(name)) {
                semanticErrorOccurred("Cannot assign value to a function: " + name, id.pos)
              }
              val newIdName = scopePrefix ++ name
              if (isInferredTypeDef(lVal, newIdName, varsInScope.values.toList)) {
                // If we are here then the LValue type is locally inferred
                localSymTable = localSymTable.concat(Map(name -> newIdName))
                rType = checkType(newRVal)
                lType = rType

                var newIdType = lType
                lType match {
                  case p@PairType(_, _) =>
                    globalScopePrefix = scopePrefix
                    newIdType = toFullPair(p, rVal)
                  case _ =>
                }

                symTable += (newIdName -> newIdType)
              } else if (isTypelessParam(lVal)) {
                // If we are here then the LValue is a typeless parameter
                localSymTable = localSymTable.concat(Map(name -> newIdName))
                rType = checkType(newRVal)
                lType = rType

                var newIdType = lType
                lType match {
                  case p@PairType(_, _) =>
                    globalScopePrefix = scopePrefix
                    newIdType = toFullPair(p, rVal)
                  case _ =>
                }

                symTable += (newIdName -> newIdType)
              } else {
                // If we are here then the LValue is being reassigned to a value following traditional WACC
                val tempLVal = checkExpr(lVal, varsInScope ++ localSymTable)
                lType = checkType(tempLVal)
                rType = checkType(newRVal)
                if (rType == NoType) {
                  rType = checkType(newRVal)
                }
              }
            case elem@ArrayElem(identArray, exprs) =>
              globalScopePrefix = scopePrefix
              val name = identFromIdentArray(identArray)
              val newIdName = scopePrefix ++ name
              lType = checkType(elem: LValue)
              rType = checkType(newRVal)

              if (!isDeclaredOutside(newIdName, symTable.keys.toList)._2) {
                localSymTable = localSymTable.concat(Map(name -> newIdName))
              }
            case pf@PairFst(fst) =>

              val name = identFromPairElem(pf)
              val newIdName = scopePrefix + name
              lType = checkType(pf: LValue)
              rType = checkType(newRVal)

              if (!isDeclaredOutside(newIdName, symTable.keys.toList)._2) {
                localSymTable = localSymTable.concat(Map(name -> newIdName))
              }
            case ps@PairSnd(snd) =>
              val name = identFromPairElem(ps)
              val newIdName = scopePrefix + name
              lType = checkType(ps: LValue)
              rType = checkType(newRVal)

              if (!isDeclaredOutside(newIdName, symTable.keys.toList)._2) {
                localSymTable = localSymTable.concat(Map(name -> newIdName))
              }
          }

          val newLVal = checkExpr(lVal, varsInScope ++ localSymTable)

          // Check for type mismatch in assignment
          //  !sameType(checkType(lVal), checkType(newRVal)) && checkType(lVal) != NoTypeExists
          if (!sameType(lType, rType)) {
            semanticErrorOccurred(s"Type mismatch in assignment: expected $lType, found $rType", stat.pos)
          } else if (lType == AnyType && rType == AnyType) {
            semanticErrorOccurred("Types unclear on both sides of assignment", stat.pos)
          }

          new AssignorInferDecl(newLVal, newRVal)(stat.pos)

        case Read(expr) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)

          // Check if the variable being read is of type int, char, or string
          checkType(newExpr) match {
            case IntType() =>
            case CharType() =>
            case StringType() =>
            case _ => semanticErrorOccurred(s"Variable attempting read has incorrect type ${checkType(newExpr)}, can only be of type <int>, <char> or <string>", stat.pos)
          }

          new Read(newExpr)(stat.pos)

        case Free(expr) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)

          // Check if the expression to be freed is of type Pair or Array
          checkType(newExpr) match {
            case PairType(_, _) | ArrayType(_) =>
            case _ => semanticErrorOccurred(s"Only Pair and Array types can be freed, is type ${checkType(newExpr)}", stat.pos)
          }

          new Free(newExpr)(stat.pos)

        case Return(expr) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)

          // Check for return statement outside of a function or type mismatch in return type
          var checkReturn = returnType
          if (checkReturn == null) {
            semanticErrorOccurred("Return statement outside of a function is not allowed", stat.pos)
          } else if (!sameType(checkType(newExpr), checkReturn)) {
            // Try to infer the function type one last time
            val funcCalledName = funcName match {
              case Some(x) =>
                x.substring(x.indexOf("-") + 1, x.lastIndexOf("-"))
              case None =>
            }
            val funcCalled = funcTable.find(f => f.ident.name == funcCalledName)
            funcCalled match {
              case Some(x) =>
                checkReturn = inferFuncReturnType(x.ident, x.stats, globalFilename, symTable, funcTable)
              case None =>
            }

          } else if (!sameType(checkType(newExpr), checkReturn) && checkType(newExpr) != NoTypeExists) {
            semanticErrorOccurred(s"Type mismatch in Return: expected $checkReturn, found ${checkType(expr)}", stat.pos)
          }

          new Return(newExpr)(stat.pos)

        case Exit(expr) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)

          // Check if the exit code is of type int
          checkType(newExpr) match {
            case IntType() =>
            case _ => semanticErrorOccurred(s"Exit code defined is not of type <int>, is type ${checkType(newExpr)}", newExpr.pos)
          }

          new Exit(newExpr)(stat.pos)

        case Print(expr) =>
          new Print(checkExpr(expr, varsInScope ++ localSymTable))(stat.pos)

        case Println(expr) =>
          new Println(checkExpr(expr, varsInScope ++ localSymTable))(stat.pos)

        case If(expr, thenStat, elseStat) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)

          // Check if the condition for the If statement is of type bool
          checkType(newExpr) match {
            case BoolType() =>
            case NoTypeExists =>
            case _ => semanticErrorOccurred("Condition for If statement is not of type <bool>", expr.pos)
          }

          // Check the statements inside the then and else blocks
          val newThenStat = checkStatements(thenStat, varsInScope ++ localSymTable, returnType, s"$scopePrefix${scopeIndex}if-then-")
          val newElseStat = checkStatements(elseStat, varsInScope ++ localSymTable, returnType, s"$scopePrefix${scopeIndex}if else-")
          scopeIndex += 1
          new If(newExpr, newThenStat, newElseStat)(stat.pos)

        case While(expr, whileBody) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)

          // Check if the condition for the While statement is of type bool
          checkType(newExpr) match {
            case BoolType() =>
            case NoTypeExists =>
            case _ => semanticErrorOccurred("Condition for While statement is not of type <bool>", expr.pos)
          }

          // Check the statements inside the while loop
          val newBody = checkStatements(whileBody, varsInScope ++ localSymTable, returnType, s"$scopePrefix${scopeIndex}while-")
          scopeIndex += 1
          new While(newExpr, newBody)(stat.pos)

        case Scope(body) =>
          // Check the statements inside the scope
          val newBody = checkStatements(body, varsInScope ++ localSymTable, returnType, s"$scopePrefix%${scopeIndex}scope-")
          scopeIndex += 1
          new Scope(newBody)(stat.pos)
      }
      checkedStat
    }

    // Iterate through each statement in the list
    for (stat <- stats) {
      val checkedStat = checkStatement(stat)
      newStats += checkedStat

    }
    newStats.toList // Return the list of checked statements
  }

  // Helper function to infer return type of a function
  private def inferFuncReturnType(ident: Ident, stats: List[Stat], file: String, varTable: mutable.Map[String, Type], funcTbl: List[Func]): Type = {
    // Initialize inferred return types as empty list buffer
    val returnTypes: ListBuffer[Type] = ListBuffer.empty

    implicit val fileName: String = file

    // Read file contents
    val fileSource = Source.fromFile(new File(file))
    implicit val fileContents: Array[String] = fileSource.getLines().toArray
    fileSource.close()

    // Initialize symbol table and error buffer
    implicit val symTable: mutable.Map[String, Type] = varTable
    implicit val errors: mutable.ListBuffer[WaccError] = mutable.ListBuffer.empty[WaccError]
    implicit val funcTable: List[Func] = funcTbl
    implicit val funcName: Option[String] = Option(ident.name)

    def translateScopeVar(sym: String): (String, String) = {
      val identIndex = sym.lastIndexOf("-")
      if (identIndex >= 0 && identIndex < sym.length - 1)
        (sym.substring(identIndex + 1), sym)
      else
      ("", "")
    }

    val varsInScope: mutable.Map[String, String] = symTable.map { case (key, _) =>
      translateScopeVar(key)
    }



    // Traverse the statements in reverse order to find the last return statement
    for (stat <- stats.reverse) {
      stat match {
        case Return(expr) =>
          // If a return statement is found, infer the type of the expression
          returnTypes.addOne(checkType(checkExpr(expr, varsInScope)))
        case Exit(expr) =>
          returnTypes.addOne(checkType(checkExpr(expr, varsInScope)))
        case If(_, thenStats, elseStats) =>
          // If statement: recursively infer return type from both branches
          returnTypes.addOne(inferFuncReturnType(ident, thenStats, file, symTable, funcTable))
          returnTypes.addOne(inferFuncReturnType(ident, elseStats, file, symTable, funcTable))
        case While(_, whileStats) =>
          // While loop: recursively infer return type from the loop body
          returnTypes.addOne(inferFuncReturnType(ident, whileStats, file, symTable, funcTable))
        case _ => // For other statements, continue traversing
      }
    }

    // Check that all return types are the same and then return the type is so
    if (returnTypes.isEmpty) {
      NoType
    } else {
      val firstType = returnTypes.head
      if (returnTypes.tail.forall(_ == firstType)) {
        firstType
      } else {
        val func = funcTbl.find(f => f.ident.name == funcName.get)
        semanticErrorOccurred(s"Function ${funcName.get.replace(waccPrefix, "")} has diverging return types", func.get.pos)
        NoType
      }
    }
  }

  // Helper function to find the most specific common type between two types
  private def findCommonType(type1: Type, type2: Type): Type = {
    // Logic to determine the most specific common type
    // For simplicity, let's assume the types are compatible
    if (type1 != NoType && type2 != NoType && type1 == type2) {
      type1
    } else if (type1 == NoType && type2 != NoType) {
      type2
    } else if (type1 != NoType && type2 == NoType) {
      type1
    } else {
      NoType
    }
  }


  // Checks the semantics of a WACC program, including syntax correctness, type checking, and scoping rules.
  def checkSemantics(inProg: Prog, file: String): (List[WaccError], Prog, mutable.Map[String, Type]) = {

    // Set global file name
    globalFilename = file

    // Implicit parameters for function and file context
    implicit val funcTable: List[Func] = inProg.funcs.map {
      case x@Func(funcType, id, params, funcStats) =>
        new Func(funcType, Ident(waccPrefix + id.name)(id.pos), params, funcStats)(x.pos)
    }
    implicit val fileName: String = file

    // Read file contents
    val fileSource = Source.fromFile(new File(file))
    implicit val fileContents: Array[String] = fileSource.getLines().toArray
    fileSource.close()

    // Initialize symbol table and error buffer
    implicit val symTable: mutable.Map[String, Type] = mutable.LinkedHashMap[String, Type]()
    implicit val errors: mutable.ListBuffer[WaccError] = mutable.ListBuffer.empty[WaccError]

    // Initialize main scope
    implicit val mainScope: Option[String] = Option.empty

    // Check for duplicated function declarations and arguments
    var tempFuncTable: List[Func] = Nil
    val newFuncs = funcTable.map(x => {
      if (tempFuncTable.exists(y => y.ident.name == x.ident.name)) {
        semanticErrorOccurred(s"Duplicated function declaration: ${x.ident.name.replace(waccPrefix, "")}", x.pos)
      } else {
        tempFuncTable = tempFuncTable :+ x
      }
      var argList: List[Param] = Nil
      x.paramList.foreach(a => if (argList.exists(b => a.ident.name == b.ident.name)) {
        semanticErrorOccurred(s"Duplicated function argument ${a.ident.name.replace(waccPrefix, "")} in function ${x.ident.name.replace(waccPrefix, "")}", a.pos)
      } else {
        argList = argList :+ a
      })
      val funcScopePrefix = s"func-${x.ident.name}-"


      val mBuilder = mutable.Map.newBuilder[String, String]
      mBuilder ++= x.paramList.map(y => y.ident.name -> (funcScopePrefix ++ "param-" ++ y.ident.name))
      val m: mutable.Map[String, String] = mBuilder.result()

      def trySetTypelessRParam(param: LRValue, rType: Type): Unit = {
        param match {
          case Ident(name) =>
            val symName = funcScopePrefix ++ "param-" ++ name
            symTable.get(symName) match {
              case Some(x) =>
                if (x == NoType) {
                  val funcStartInd = funcScopePrefix.indexOf("func-") + "func-".length
                  val funcEndInd = funcScopePrefix.lastIndexOf("-")
                  val funcName = funcScopePrefix.substring(funcStartInd, funcEndInd)
                  symTable += symName -> rType
                  val func: Func = funcTable.find(f => f.ident.name == funcName).get
                  func.paramList.find(p => p.ident.name == name).get.typ = Option(rType)
                }
              case None =>
            }
          case _ =>
        }
      }

      def inferParamType(stat: Stat, returnType: Type): Unit = {
        stat match {
          case Declaration(_, _, rVal) =>
            checkRValParam(rVal)
          case AssignorInferDecl(_, rVal) =>
            checkRValParam(rVal)
          case Return(exp) =>
            trySetTypelessRParam(exp, returnType)
            checkRValParam(exp)
          case Exit(exp) =>
            trySetTypelessRParam(exp, IntType()(exp.pos))
            checkRValParam(exp)
          case If(cond, thenStats, elseStats) =>
            trySetTypelessRParam(cond, BoolType()(cond.pos))

            thenStats.foreach(thenStat => inferParamType(thenStat, returnType))
            elseStats.foreach(elseStat => inferParamType(elseStat, returnType))
            checkRValParam(cond)
          case While(cond, doStats) =>
            trySetTypelessRParam(cond, BoolType()(cond.pos))

            doStats.foreach(doStat => inferParamType(doStat, returnType))
            checkRValParam(cond)
          case Scope(scopeStats) =>
            checkStatements(scopeStats, m, returnType, funcScopePrefix)
          case _ =>
        }
      }

      def inferSingleBinOp(exp1: Expr, exp2: Expr, typeToSet: Type): Unit = {
        trySetTypelessRParam(exp1, typeToSet)
        trySetTypelessRParam(exp2, typeToSet)
      }

      def inferBinOp(exp1: Expr, exp2: Expr): Unit = {
        val type2 = checkType(exp2)
        if (type2 != NoTypeExists) {
          trySetTypelessRParam(exp1, type2)
        }
        val type1 = checkType(exp1)
        if (type1 != NoTypeExists) {
          trySetTypelessRParam(exp2, type1)
        }
      }

      def checkRValParam(rVal: RValue): Unit = {
        rVal match {

          // Unary Operators
          case Chr(inside) =>
            trySetTypelessRParam(inside, IntType()(inside.pos))
          case Len(inside) =>
            trySetTypelessRParam(inside, ArrayType(AnyType)(inside.pos))
          case Neg(inside) =>
            trySetTypelessRParam(inside, IntType()(inside.pos))
          case Not(inside) =>
            trySetTypelessRParam(inside, BoolType()(inside.pos))
          case Ord(inside) =>
            trySetTypelessRParam(inside, CharType()(inside.pos))

          // Binary Operators
          case Sub(x, y) =>
            inferSingleBinOp(x, y, IntType()(rVal.pos))
          case Add(x, y) =>
            inferSingleBinOp(x, y, IntType()(rVal.pos))
          case Mul(x, y) =>
            inferSingleBinOp(x, y, IntType()(rVal.pos))
          case Div(x, y) =>
            inferSingleBinOp(x, y, IntType()(rVal.pos))
          case Mod(x, y) =>
            inferSingleBinOp(x, y, IntType()(rVal.pos))
          case And(x, y) =>
            inferSingleBinOp(x, y, BoolType()(rVal.pos))
          case Or(x, y) =>
            inferSingleBinOp(x, y, BoolType()(rVal.pos))
          case GT(x, y) =>
            inferBinOp(x, y)
          case GTE(x, y) =>
            inferBinOp(x, y)
          case LT(x, y) =>
            inferBinOp(x, y)
          case LTE(x, y) =>
            inferBinOp(x, y)
          case Eq(x, y) =>
            inferBinOp(x, y)
          case NEq(x, y) =>
            inferBinOp(x, y)

          case elem@ArrayElem(_, _)  =>
            trySetTypelessRParam(elem, IntType()(elem.pos))

          case NewPair(fst, snd) =>
            trySetTypelessRParam(fst, checkType(fst))
            trySetTypelessRParam(snd, checkType(snd))

          case _ =>
        }
      }

      x.paramList.foreach(y => {
        symTable += (funcScopePrefix ++ "param-" ++ y.ident.name) -> y.typ.getOrElse(NoType)
      })

      globalScopePrefix = funcScopePrefix

      // Traverse function statements for internal check on parameter types
      x.stats.foreach(stat => inferParamType(stat, x.typ.getOrElse(NoType)))

        new Func(x.typ, x.ident, x.paramList,
          checkStatements(x.stats, m, x.typ.getOrElse(NoType), funcScopePrefix))(x.pos)
    })

    val checkedStatements = checkStatements(inProg.stats, mutable.Map.empty, null, "main-")
    // Check statements within the main scope
    // Check that all parameter types have been inferred and throw error otherwise
    newFuncs.foreach(f => {
      f.paramList.foreach(y => {
        val funcScopePrefix = s"func-${f.ident.name}-"
        val foundType: Type = symTable(funcScopePrefix ++ "param-" ++ y.ident.name)
        if (foundType == NoType) {
          semanticErrorOccurred("Type of parameter could not be inferred: " + y.ident, y.pos)
        }
      })
        val inferredType: Type = inferFuncReturnType(f.ident, f.stats, file, symTable, funcTable)
        if (inferredType == NoType) {
          semanticErrorOccurred("Return type of function could not be inferred: " + f.ident, f.pos)
        }
        if (f.typ.isEmpty) {
          f.typ = Option(inferredType)
        }
    })

    val newProg = new Prog(newFuncs, checkedStatements)(inProg.pos)

    (errors.toList, newProg, symTable)
  }

}
